#!/bin/sh

### BEGIN INIT INFO
# Provides:          virtualbox-SHORTNAME
# Required-Start:    $local_fs $remote_fs vboxdrv virtualbox
# Required-Stop:     $local_fs $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: virtual machine "LONGNAME"
# Description:       VirtualBox virtual machine "LONGNAME"
### END INIT INFO

# original author: Brendan Kidwell <brendan@glump.net>
# original source:
# https://forums.virtualbox.org/viewtopic.php?f=7&t=34790#p193078
# http://www.glump.net/howto/virtualbox_as_a_service
#
# heavily modified (rewritten, really) by:
# Daniel Malament <daniel.j.malament@gmail.com>

# Based on /etc/init.d/skeleton from Ubuntu 8.04. Updated for Ubuntu 9.10.
# If you are using Ubuntu <9.10, you might need to change "Default-Stop"
# above to "S 0 1 6".

# Do NOT "set -e"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH="/usr/sbin:/usr/bin:/sbin:/bin"
DESC="VirtualBox virtual machine \"LONGNAME\""
NAME="virtualbox-SHORTNAME"
SCRIPTNAME="/etc/init.d/$NAME"

MANAGE_CMD="VBoxManage"
HEADLESS_CMD="VBoxHeadless"

VM_OWNER="USERNAME"
VM_NAME="LONGNAME"  # must match registered name in VirtualBox

GOOD_RV="0"
WARN_RV="255"
FAIL_RV="1"

# Read configuration variable file if it is present
[ -r "/etc/default/$NAME" ] && . "/etc/default/$NAME"

# Load the VERBOSE setting and other rcS variables
#[ -f /etc/default/rcS ] && . /etc/default/rcS

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
# Returns:
#   GOOD_RV if daemon has been started
#   WARN_RV if daemon was already running
#   FAIL_RV if daemon could not be started
#
do_start() {
  sudo -H -u "$VM_OWNER" "$MANAGE_CMD" showvminfo "$VM_NAME" | \
       grep "^State:\s*running" > /dev/null && {
    log_warning_msg "VM \"$VM_NAME\" is already running"
    log_end_msg "$WARN_RV"
    return "$WARN_RV"
  }

  #sudo -H -u "$VM_OWNER" "$MANAGE_CMD" startvm "$VM_NAME" -type vrdp \
  #     >/dev/null || {
  #  log_failure_msg "Failed to start VM \"$VM_NAME\""
  #  log_end_msg "$FAIL_RV"
  #  return "$FAIL_RV"
  #}

  # can't check for success this way, but can't use built-in VNC otherwise
  sudo -H -u "$VM_OWNER" screen -dmS "$NAME" \
       "$HEADLESS_CMD" --startvm "$VM_NAME" --vrde=off -n
       # -m PORT -o 'PASSWORD'

  log_success_msg "VM \"$VM_NAME\" started or resumed"
  log_end_msg "$GOOD_RV"
  return "$GOOD_RV"
}

#
# Function that stops the daemon/service
#
# Returns:
#   GOOD_RV if daemon has been stopped
#   WARN_RV if daemon was already stopped
#   FAIL_RV if daemon could not be stopped
#   other if a failure occurred
#
do_stop() {
  sudo -H -u "$VM_OWNER" "$MANAGE_CMD" showvminfo "$VM_NAME" | \
       grep "^State:\s*running" > /dev/null || {
    log_warning_msg "VM \"$VM_NAME\" is already stopped/suspended"
    log_end_msg "$WARN_RV"
    return "$WARN_RV"
  }

  sudo -H -u "$VM_OWNER" "$MANAGE_CMD" controlvm "$VM_NAME" savestate || {
    log_failure_msg "Failed to suspend VM \"$VM_NAME\""
    log_end_msg "$FAIL_RV"
    return "$FAIL_RV"
  }

  log_success_msg "VM \"$VM_NAME\" suspended"
  log_end_msg "$GOOD_RV"
  return "$GOOD_RV"
}

#
# Display "State" field from showinfo action
#
do_status()
{
    sudo -H -u "$VM_OWNER" "$MANAGE_CMD" showvminfo "$VM_NAME" | \
         grep "^State:\s*.*$"
}

case "$1" in
  start)
    # message here so it isn't printed for reload
    log_daemon_msg "Starting $DESC"
    do_start
    ;;
  stop)
    # message here so it isn't printed for reload
    log_daemon_msg "Stopping $DESC"
    do_stop
    ;;
  restart|force-reload)
    #
    # If the 'reload' option is implemented then remove the
    # 'force-reload' alias
    #
    log_daemon_msg "Restarting $DESC"
    do_stop
    case "$?" in
      "$GOOD_RV"|"$WARN_RV")
        do_start
        ;;
      *)
        # Failed to stop
        log_end_msg "$FAIL_RV"
        ;;
    esac
    ;;
  status)
    do_status
    ;;
  *)
    #echo "Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}" >&2
    echo "Usage: $SCRIPTNAME {start|stop|restart|force-reload|status}" >&2
    exit 3
    ;;
esac
